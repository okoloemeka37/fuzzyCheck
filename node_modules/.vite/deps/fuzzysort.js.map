{
  "version": 3,
  "sources": ["../../fuzzysort/fuzzysort.js"],
  "sourcesContent": ["// https://github.com/farzher/fuzzysort v3.0.2\r\n\r\n// UMD (Universal Module Definition) for fuzzysort\r\n;((root, UMD) => {\r\n  if(typeof define === 'function' && define.amd) define([], UMD)\r\n  else if(typeof module === 'object' && module.exports) module.exports = UMD()\r\n  else root['fuzzysort'] = UMD()\r\n})(this, _ => {\r\n  'use strict'\r\n\r\n  var single = (search, target) => {\r\n    if(!search || !target) return NULL\r\n\r\n    var preparedSearch = getPreparedSearch(search)\r\n    if(!isPrepared(target)) target = getPrepared(target)\r\n\r\n    var searchBitflags = preparedSearch.bitflags\r\n    if((searchBitflags & target._bitflags) !== searchBitflags) return NULL\r\n\r\n    return algorithm(preparedSearch, target)\r\n  }\r\n\r\n  var go = (search, targets, options) => {\r\n    if(!search) return options?.all ? all(targets, options) : noResults\r\n\r\n    var preparedSearch = getPreparedSearch(search)\r\n    var searchBitflags = preparedSearch.bitflags\r\n    var containsSpace  = preparedSearch.containsSpace\r\n\r\n    var threshold = denormalizeScore( options?.threshold || 0 )\r\n    var limit     = options?.limit || INFINITY\r\n\r\n    var resultsLen = 0; var limitedCount = 0\r\n    var targetsLen = targets.length\r\n\r\n    function push_result(result) {\r\n      if(resultsLen < limit) { q.add(result); ++resultsLen }\r\n      else {\r\n        ++limitedCount\r\n        if(result._score > q.peek()._score) q.replaceTop(result)\r\n      }\r\n    }\r\n\r\n    // This code is copy/pasted 3 times for performance reasons [options.key, options.keys, no keys]\r\n\r\n    // options.key\r\n    if(options?.key) {\r\n      var key = options.key\r\n      for(var i = 0; i < targetsLen; ++i) { var obj = targets[i]\r\n        var target = getValue(obj, key)\r\n        if(!target) continue\r\n        if(!isPrepared(target)) target = getPrepared(target)\r\n\r\n        if((searchBitflags & target._bitflags) !== searchBitflags) continue\r\n        var result = algorithm(preparedSearch, target)\r\n        if(result === NULL) continue\r\n        if(result._score < threshold) continue\r\n\r\n        result.obj = obj\r\n        push_result(result)\r\n      }\r\n\r\n    // options.keys\r\n    } else if(options?.keys) {\r\n      var keys = options.keys\r\n      var keysLen = keys.length\r\n\r\n      outer: for(var i = 0; i < targetsLen; ++i) { var obj = targets[i]\r\n\r\n        { // early out based on bitflags\r\n          var keysBitflags = 0\r\n          for (var keyI = 0; keyI < keysLen; ++keyI) {\r\n            var key = keys[keyI]\r\n            var target = getValue(obj, key)\r\n            if(!target) { tmpTargets[keyI] = noTarget; continue }\r\n            if(!isPrepared(target)) target = getPrepared(target)\r\n            tmpTargets[keyI] = target\r\n\r\n            keysBitflags |= target._bitflags\r\n          }\r\n\r\n          if((searchBitflags & keysBitflags) !== searchBitflags) continue\r\n        }\r\n\r\n        if(containsSpace) for(let i=0; i<preparedSearch.spaceSearches.length; i++) keysSpacesBestScores[i] = NEGATIVE_INFINITY\r\n\r\n        for (var keyI = 0; keyI < keysLen; ++keyI) {\r\n          target = tmpTargets[keyI]\r\n          if(target === noTarget) { tmpResults[keyI] = noTarget; continue }\r\n\r\n          tmpResults[keyI] = algorithm(preparedSearch, target, /*allowSpaces=*/false, /*allowPartialMatch=*/containsSpace)\r\n          if(tmpResults[keyI] === NULL) { tmpResults[keyI] = noTarget; continue }\r\n\r\n          // todo: this seems weird and wrong. like what if our first match wasn't good. this should just replace it instead of averaging with it\r\n          // if our second match isn't good we ignore it instead of averaging with it\r\n          if(containsSpace) for(let i=0; i<preparedSearch.spaceSearches.length; i++) {\r\n            if(allowPartialMatchScores[i] > -1000) {\r\n              if(keysSpacesBestScores[i] > NEGATIVE_INFINITY) {\r\n                var tmp = (keysSpacesBestScores[i] + allowPartialMatchScores[i]) / 4/*bonus score for having multiple matches*/\r\n                if(tmp > keysSpacesBestScores[i]) keysSpacesBestScores[i] = tmp\r\n              }\r\n            }\r\n            if(allowPartialMatchScores[i] > keysSpacesBestScores[i]) keysSpacesBestScores[i] = allowPartialMatchScores[i]\r\n          }\r\n        }\r\n\r\n        if(containsSpace) {\r\n          for(let i=0; i<preparedSearch.spaceSearches.length; i++) { if(keysSpacesBestScores[i] === NEGATIVE_INFINITY) continue outer }\r\n        } else {\r\n          var hasAtLeast1Match = false\r\n          for(let i=0; i < keysLen; i++) { if(tmpResults[i]._score !== NEGATIVE_INFINITY) { hasAtLeast1Match = true; break } }\r\n          if(!hasAtLeast1Match) continue\r\n        }\r\n\r\n        var objResults = new KeysResult(keysLen)\r\n        for(let i=0; i < keysLen; i++) { objResults[i] = tmpResults[i] }\r\n\r\n        if(containsSpace) {\r\n          var score = 0\r\n          for(let i=0; i<preparedSearch.spaceSearches.length; i++) score += keysSpacesBestScores[i]\r\n        } else {\r\n          // todo could rewrite this scoring to be more similar to when there's spaces\r\n          // if we match multiple keys give us bonus points\r\n          var score = NEGATIVE_INFINITY\r\n          for(let i=0; i<keysLen; i++) {\r\n            var result = objResults[i]\r\n            if(result._score > -1000) {\r\n              if(score > NEGATIVE_INFINITY) {\r\n                var tmp = (score + result._score) / 4/*bonus score for having multiple matches*/\r\n                if(tmp > score) score = tmp\r\n              }\r\n            }\r\n            if(result._score > score) score = result._score\r\n          }\r\n        }\r\n\r\n        objResults.obj = obj\r\n        objResults._score = score\r\n        if(options?.scoreFn) {\r\n          score = options.scoreFn(objResults)\r\n          if(!score) continue\r\n          score = denormalizeScore(score)\r\n          objResults._score = score\r\n        }\r\n\r\n        if(score < threshold) continue\r\n        push_result(objResults)\r\n      }\r\n\r\n    // no keys\r\n    } else {\r\n      for(var i = 0; i < targetsLen; ++i) { var target = targets[i]\r\n        if(!target) continue\r\n        if(!isPrepared(target)) target = getPrepared(target)\r\n\r\n        if((searchBitflags & target._bitflags) !== searchBitflags) continue\r\n        var result = algorithm(preparedSearch, target)\r\n        if(result === NULL) continue\r\n        if(result._score < threshold) continue\r\n\r\n        push_result(result)\r\n      }\r\n    }\r\n\r\n    if(resultsLen === 0) return noResults\r\n    var results = new Array(resultsLen)\r\n    for(var i = resultsLen - 1; i >= 0; --i) results[i] = q.poll()\r\n    results.total = resultsLen + limitedCount\r\n    return results\r\n  }\r\n\r\n\r\n  // this is written as 1 function instead of 2 for minification. perf seems fine ...\r\n  // except when minified. the perf is very slow\r\n  var highlight = (result, open='<b>', close='</b>') => {\r\n    var callback = typeof open === 'function' ? open : undefined\r\n\r\n    var target      = result.target\r\n    var targetLen   = target.length\r\n    var indexes     = result.indexes\r\n    var highlighted = ''\r\n    var matchI      = 0\r\n    var indexesI    = 0\r\n    var opened      = false\r\n    var parts       = []\r\n\r\n    for(var i = 0; i < targetLen; ++i) { var char = target[i]\r\n      if(indexes[indexesI] === i) {\r\n        ++indexesI\r\n        if(!opened) { opened = true\r\n          if(callback) {\r\n            parts.push(highlighted); highlighted = ''\r\n          } else {\r\n            highlighted += open\r\n          }\r\n        }\r\n\r\n        if(indexesI === indexes.length) {\r\n          if(callback) {\r\n            highlighted += char\r\n            parts.push(callback(highlighted, matchI++)); highlighted = ''\r\n            parts.push(target.substr(i+1))\r\n          } else {\r\n            highlighted += char + close + target.substr(i+1)\r\n          }\r\n          break\r\n        }\r\n      } else {\r\n        if(opened) { opened = false\r\n          if(callback) {\r\n            parts.push(callback(highlighted, matchI++)); highlighted = ''\r\n          } else {\r\n            highlighted += close\r\n          }\r\n        }\r\n      }\r\n      highlighted += char\r\n    }\r\n\r\n    return callback ? parts : highlighted\r\n  }\r\n\r\n\r\n  var prepare = (target) => {\r\n    if(typeof target === 'number') target = ''+target\r\n    else if(typeof target !== 'string') target = ''\r\n    var info = prepareLowerInfo(target)\r\n    return new_result(target, {_targetLower:info._lower, _targetLowerCodes:info.lowerCodes, _bitflags:info.bitflags})\r\n  }\r\n\r\n  var cleanup = () => { preparedCache.clear(); preparedSearchCache.clear() }\r\n\r\n\r\n  // Below this point is only internal code\r\n  // Below this point is only internal code\r\n  // Below this point is only internal code\r\n  // Below this point is only internal code\r\n\r\n\r\n  class Result {\r\n    get ['indexes']() { return this._indexes.slice(0, this._indexes.len).sort((a,b)=>a-b) }\r\n    set ['indexes'](indexes) { return this._indexes = indexes }\r\n    ['highlight'](open, close) { return highlight(this, open, close) }\r\n    get ['score']() { return normalizeScore(this._score) }\r\n    set ['score'](score) { this._score = denormalizeScore(score) }\r\n  }\r\n\r\n  class KeysResult extends Array {\r\n    get ['score']() { return normalizeScore(this._score) }\r\n    set ['score'](score) { this._score = denormalizeScore(score) }\r\n  }\r\n\r\n  var new_result = (target, options) => {\r\n    const result = new Result()\r\n    result['target']             = target\r\n    result['obj']                = options.obj                   ?? NULL\r\n    result._score                = options._score                ?? NEGATIVE_INFINITY\r\n    result._indexes              = options._indexes              ?? []\r\n    result._targetLower          = options._targetLower          ?? ''\r\n    result._targetLowerCodes     = options._targetLowerCodes     ?? NULL\r\n    result._nextBeginningIndexes = options._nextBeginningIndexes ?? NULL\r\n    result._bitflags             = options._bitflags             ?? 0\r\n    return result\r\n  }\r\n\r\n\r\n  var normalizeScore = score => {\r\n    if(score === NEGATIVE_INFINITY) return 0\r\n    if(score > 1) return score\r\n    return Math.E ** ( ((-score + 1)**.04307 - 1) * -2)\r\n  }\r\n  var denormalizeScore = normalizedScore => {\r\n    if(normalizedScore === 0) return NEGATIVE_INFINITY\r\n    if(normalizedScore > 1) return normalizedScore\r\n    return 1 - Math.pow((Math.log(normalizedScore) / -2 + 1), 1 / 0.04307)\r\n  }\r\n\r\n\r\n  var prepareSearch = (search) => {\r\n    if(typeof search === 'number') search = ''+search\r\n    else if(typeof search !== 'string') search = ''\r\n    search = search.trim()\r\n    var info = prepareLowerInfo(search)\r\n\r\n    var spaceSearches = []\r\n    if(info.containsSpace) {\r\n      var searches = search.split(/\\s+/)\r\n      searches = [...new Set(searches)] // distinct\r\n      for(var i=0; i<searches.length; i++) {\r\n        if(searches[i] === '') continue\r\n        var _info = prepareLowerInfo(searches[i])\r\n        spaceSearches.push({lowerCodes:_info.lowerCodes, _lower:searches[i].toLowerCase(), containsSpace:false})\r\n      }\r\n    }\r\n\r\n    return {lowerCodes: info.lowerCodes, _lower: info._lower, containsSpace: info.containsSpace, bitflags: info.bitflags, spaceSearches: spaceSearches}\r\n  }\r\n\r\n\r\n\r\n  var getPrepared = (target) => {\r\n    if(target.length > 999) return prepare(target) // don't cache huge targets\r\n    var targetPrepared = preparedCache.get(target)\r\n    if(targetPrepared !== undefined) return targetPrepared\r\n    targetPrepared = prepare(target)\r\n    preparedCache.set(target, targetPrepared)\r\n    return targetPrepared\r\n  }\r\n  var getPreparedSearch = (search) => {\r\n    if(search.length > 999) return prepareSearch(search) // don't cache huge searches\r\n    var searchPrepared = preparedSearchCache.get(search)\r\n    if(searchPrepared !== undefined) return searchPrepared\r\n    searchPrepared = prepareSearch(search)\r\n    preparedSearchCache.set(search, searchPrepared)\r\n    return searchPrepared\r\n  }\r\n\r\n\r\n  var all = (targets, options) => {\r\n    var results = []; results.total = targets.length // this total can be wrong if some targets are skipped\r\n\r\n    var limit = options?.limit || INFINITY\r\n\r\n    if(options?.key) {\r\n      for(var i=0;i<targets.length;i++) { var obj = targets[i]\r\n        var target = getValue(obj, options.key)\r\n        if(target == NULL) continue\r\n        if(!isPrepared(target)) target = getPrepared(target)\r\n        var result = new_result(target.target, {_score: target._score, obj: obj})\r\n        results.push(result); if(results.length >= limit) return results\r\n      }\r\n    } else if(options?.keys) {\r\n      for(var i=0;i<targets.length;i++) { var obj = targets[i]\r\n        var objResults = new KeysResult(options.keys.length)\r\n        for (var keyI = options.keys.length - 1; keyI >= 0; --keyI) {\r\n          var target = getValue(obj, options.keys[keyI])\r\n          if(!target) { objResults[keyI] = noTarget; continue }\r\n          if(!isPrepared(target)) target = getPrepared(target)\r\n          target._score = NEGATIVE_INFINITY\r\n          target._indexes.len = 0\r\n          objResults[keyI] = target\r\n        }\r\n        objResults.obj = obj\r\n        objResults._score = NEGATIVE_INFINITY\r\n        results.push(objResults); if(results.length >= limit) return results\r\n      }\r\n    } else {\r\n      for(var i=0;i<targets.length;i++) { var target = targets[i]\r\n        if(target == NULL) continue\r\n        if(!isPrepared(target)) target = getPrepared(target)\r\n        target._score = NEGATIVE_INFINITY\r\n        target._indexes.len = 0\r\n        results.push(target); if(results.length >= limit) return results\r\n      }\r\n    }\r\n\r\n    return results\r\n  }\r\n\r\n\r\n  var algorithm = (preparedSearch, prepared, allowSpaces=false, allowPartialMatch=false) => {\r\n    if(allowSpaces===false && preparedSearch.containsSpace) return algorithmSpaces(preparedSearch, prepared, allowPartialMatch)\r\n\r\n    var searchLower      = preparedSearch._lower\r\n    var searchLowerCodes = preparedSearch.lowerCodes\r\n    var searchLowerCode  = searchLowerCodes[0]\r\n    var targetLowerCodes = prepared._targetLowerCodes\r\n    var searchLen        = searchLowerCodes.length\r\n    var targetLen        = targetLowerCodes.length\r\n    var searchI          = 0 // where we at\r\n    var targetI          = 0 // where you at\r\n    var matchesSimpleLen = 0\r\n\r\n    // very basic fuzzy match; to remove non-matching targets ASAP!\r\n    // walk through target. find sequential matches.\r\n    // if all chars aren't found then exit\r\n    for(;;) {\r\n      var isMatch = searchLowerCode === targetLowerCodes[targetI]\r\n      if(isMatch) {\r\n        matchesSimple[matchesSimpleLen++] = targetI\r\n        ++searchI; if(searchI === searchLen) break\r\n        searchLowerCode = searchLowerCodes[searchI]\r\n      }\r\n      ++targetI; if(targetI >= targetLen) return NULL // Failed to find searchI\r\n    }\r\n\r\n    var searchI = 0\r\n    var successStrict = false\r\n    var matchesStrictLen = 0\r\n\r\n    var nextBeginningIndexes = prepared._nextBeginningIndexes\r\n    if(nextBeginningIndexes === NULL) nextBeginningIndexes = prepared._nextBeginningIndexes = prepareNextBeginningIndexes(prepared.target)\r\n    targetI = matchesSimple[0]===0 ? 0 : nextBeginningIndexes[matchesSimple[0]-1]\r\n\r\n    // Our target string successfully matched all characters in sequence!\r\n    // Let's try a more advanced and strict test to improve the score\r\n    // only count it as a match if it's consecutive or a beginning character!\r\n    var backtrackCount = 0\r\n    if(targetI !== targetLen) for(;;) {\r\n      if(targetI >= targetLen) {\r\n        // We failed to find a good spot for this search char, go back to the previous search char and force it forward\r\n        if(searchI <= 0) break // We failed to push chars forward for a better match\r\n\r\n        ++backtrackCount; if(backtrackCount > 200) break // exponential backtracking is taking too long, just give up and return a bad match\r\n\r\n        --searchI\r\n        var lastMatch = matchesStrict[--matchesStrictLen]\r\n        targetI = nextBeginningIndexes[lastMatch]\r\n\r\n      } else {\r\n        var isMatch = searchLowerCodes[searchI] === targetLowerCodes[targetI]\r\n        if(isMatch) {\r\n          matchesStrict[matchesStrictLen++] = targetI\r\n          ++searchI; if(searchI === searchLen) { successStrict = true; break }\r\n          ++targetI\r\n        } else {\r\n          targetI = nextBeginningIndexes[targetI]\r\n        }\r\n      }\r\n    }\r\n\r\n    // check if it's a substring match\r\n    var substringIndex = searchLen <= 1 ? -1 : prepared._targetLower.indexOf(searchLower, matchesSimple[0]) // perf: this is slow\r\n    var isSubstring = !!~substringIndex\r\n    var isSubstringBeginning = !isSubstring ? false : substringIndex===0 || prepared._nextBeginningIndexes[substringIndex-1] === substringIndex\r\n\r\n    // if it's a substring match but not at a beginning index, let's try to find a substring starting at a beginning index for a better score\r\n    if(isSubstring && !isSubstringBeginning) {\r\n      for(var i=0; i<nextBeginningIndexes.length; i=nextBeginningIndexes[i]) {\r\n        if(i <= substringIndex) continue\r\n\r\n        for(var s=0; s<searchLen; s++) if(searchLowerCodes[s] !== prepared._targetLowerCodes[i+s]) break\r\n        if(s === searchLen) { substringIndex = i; isSubstringBeginning = true; break }\r\n      }\r\n    }\r\n\r\n    // tally up the score & keep track of matches for highlighting later\r\n    // if it's a simple match, we'll switch to a substring match if a substring exists\r\n    // if it's a strict match, we'll switch to a substring match only if that's a better score\r\n\r\n    var calculateScore = matches => {\r\n      var score = 0\r\n\r\n      var extraMatchGroupCount = 0\r\n      for(var i = 1; i < searchLen; ++i) {\r\n        if(matches[i] - matches[i-1] !== 1) {score -= matches[i]; ++extraMatchGroupCount}\r\n      }\r\n      var unmatchedDistance = matches[searchLen-1] - matches[0] - (searchLen-1)\r\n\r\n      score -= (12+unmatchedDistance) * extraMatchGroupCount // penality for more groups\r\n\r\n      if(matches[0] !== 0) score -= matches[0]*matches[0]*.2 // penality for not starting near the beginning\r\n\r\n      if(!successStrict) {\r\n        score *= 1000\r\n      } else {\r\n        // successStrict on a target with too many beginning indexes loses points for being a bad target\r\n        var uniqueBeginningIndexes = 1\r\n        for(var i = nextBeginningIndexes[0]; i < targetLen; i=nextBeginningIndexes[i]) ++uniqueBeginningIndexes\r\n\r\n        if(uniqueBeginningIndexes > 24) score *= (uniqueBeginningIndexes-24)*10 // quite arbitrary numbers here ...\r\n      }\r\n\r\n      score -= (targetLen - searchLen)/2 // penality for longer targets\r\n\r\n      if(isSubstring)          score /= 1+searchLen*searchLen*1 // bonus for being a full substring\r\n      if(isSubstringBeginning) score /= 1+searchLen*searchLen*1 // bonus for substring starting on a beginningIndex\r\n\r\n      score -= (targetLen - searchLen)/2 // penality for longer targets\r\n\r\n      return score\r\n    }\r\n\r\n    if(!successStrict) {\r\n      if(isSubstring) for(var i=0; i<searchLen; ++i) matchesSimple[i] = substringIndex+i // at this point it's safe to overwrite matchehsSimple with substr matches\r\n      var matchesBest = matchesSimple\r\n      var score = calculateScore(matchesBest)\r\n    } else {\r\n      if(isSubstringBeginning) {\r\n        for(var i=0; i<searchLen; ++i) matchesSimple[i] = substringIndex+i // at this point it's safe to overwrite matchehsSimple with substr matches\r\n        var matchesBest = matchesSimple\r\n        var score = calculateScore(matchesSimple)\r\n      } else {\r\n        var matchesBest = matchesStrict\r\n        var score = calculateScore(matchesStrict)\r\n      }\r\n    }\r\n\r\n    prepared._score = score\r\n\r\n    for(var i = 0; i < searchLen; ++i) prepared._indexes[i] = matchesBest[i]\r\n    prepared._indexes.len = searchLen\r\n\r\n    const result    = new Result()\r\n    result.target   = prepared.target\r\n    result._score   = prepared._score\r\n    result._indexes = prepared._indexes\r\n    return result\r\n  }\r\n  var algorithmSpaces = (preparedSearch, target, allowPartialMatch) => {\r\n    var seen_indexes = new Set()\r\n    var score = 0\r\n    var result = NULL\r\n\r\n    var first_seen_index_last_search = 0\r\n    var searches = preparedSearch.spaceSearches\r\n    var searchesLen = searches.length\r\n    var changeslen = 0\r\n\r\n    // Return _nextBeginningIndexes back to its normal state\r\n    var resetNextBeginningIndexes = () => {\r\n      for(let i=changeslen-1; i>=0; i--) target._nextBeginningIndexes[nextBeginningIndexesChanges[i*2 + 0]] = nextBeginningIndexesChanges[i*2 + 1]\r\n    }\r\n\r\n    var hasAtLeast1Match = false\r\n    for(var i=0; i<searchesLen; ++i) {\r\n      allowPartialMatchScores[i] = NEGATIVE_INFINITY\r\n      var search = searches[i]\r\n\r\n      result = algorithm(search, target)\r\n      if(allowPartialMatch) {\r\n        if(result === NULL) continue\r\n        hasAtLeast1Match = true\r\n      } else {\r\n        if(result === NULL) {resetNextBeginningIndexes(); return NULL}\r\n      }\r\n\r\n      // if not the last search, we need to mutate _nextBeginningIndexes for the next search\r\n      var isTheLastSearch = i === searchesLen - 1\r\n      if(!isTheLastSearch) {\r\n        var indexes = result._indexes\r\n\r\n        var indexesIsConsecutiveSubstring = true\r\n        for(let i=0; i<indexes.len-1; i++) {\r\n          if(indexes[i+1] - indexes[i] !== 1) {\r\n            indexesIsConsecutiveSubstring = false; break;\r\n          }\r\n        }\r\n\r\n        if(indexesIsConsecutiveSubstring) {\r\n          var newBeginningIndex = indexes[indexes.len-1] + 1\r\n          var toReplace = target._nextBeginningIndexes[newBeginningIndex-1]\r\n          for(let i=newBeginningIndex-1; i>=0; i--) {\r\n            if(toReplace !== target._nextBeginningIndexes[i]) break\r\n            target._nextBeginningIndexes[i] = newBeginningIndex\r\n            nextBeginningIndexesChanges[changeslen*2 + 0] = i\r\n            nextBeginningIndexesChanges[changeslen*2 + 1] = toReplace\r\n            changeslen++\r\n          }\r\n        }\r\n      }\r\n\r\n      score += result._score / searchesLen\r\n      allowPartialMatchScores[i] = result._score / searchesLen\r\n\r\n      // dock points based on order otherwise \"c man\" returns Manifest.cpp instead of CheatManager.h\r\n      if(result._indexes[0] < first_seen_index_last_search) {\r\n        score -= (first_seen_index_last_search - result._indexes[0]) * 2\r\n      }\r\n      first_seen_index_last_search = result._indexes[0]\r\n\r\n      for(var j=0; j<result._indexes.len; ++j) seen_indexes.add(result._indexes[j])\r\n    }\r\n\r\n    if(allowPartialMatch && !hasAtLeast1Match) return NULL\r\n\r\n    resetNextBeginningIndexes()\r\n\r\n    // allows a search with spaces that's an exact substring to score well\r\n    var allowSpacesResult = algorithm(preparedSearch, target, /*allowSpaces=*/true)\r\n    if(allowSpacesResult !== NULL && allowSpacesResult._score > score) {\r\n      if(allowPartialMatch) {\r\n        for(var i=0; i<searchesLen; ++i) {\r\n          allowPartialMatchScores[i] = allowSpacesResult._score / searchesLen\r\n        }\r\n      }\r\n      return allowSpacesResult\r\n    }\r\n\r\n    if(allowPartialMatch) result = target\r\n    result._score = score\r\n\r\n    var i = 0\r\n    for (let index of seen_indexes) result._indexes[i++] = index\r\n    result._indexes.len = i\r\n\r\n    return result\r\n  }\r\n\r\n  // we use this instead of just .normalize('NFD').replace(/[\\u0300-\\u036f]/g, '') because that screws with japanese characters\r\n  var remove_accents = (str) => str.replace(/\\p{Script=Latin}+/gu, match => match.normalize('NFD')).replace(/[\\u0300-\\u036f]/g, '')\r\n\r\n  var prepareLowerInfo = (str) => {\r\n    str = remove_accents(str)\r\n    var strLen = str.length\r\n    var lower = str.toLowerCase()\r\n    var lowerCodes = [] // new Array(strLen)    sparse array is too slow\r\n    var bitflags = 0\r\n    var containsSpace = false // space isn't stored in bitflags because of how searching with a space works\r\n\r\n    for(var i = 0; i < strLen; ++i) {\r\n      var lowerCode = lowerCodes[i] = lower.charCodeAt(i)\r\n\r\n      if(lowerCode === 32) {\r\n        containsSpace = true\r\n        continue // it's important that we don't set any bitflags for space\r\n      }\r\n\r\n      var bit = lowerCode>=97&&lowerCode<=122 ? lowerCode-97 // alphabet\r\n              : lowerCode>=48&&lowerCode<=57  ? 26           // numbers\r\n                                                             // 3 bits available\r\n              : lowerCode<=127                ? 30           // other ascii\r\n              :                                 31           // other utf8\r\n      bitflags |= 1<<bit\r\n    }\r\n\r\n    return {lowerCodes:lowerCodes, bitflags:bitflags, containsSpace:containsSpace, _lower:lower}\r\n  }\r\n  var prepareBeginningIndexes = (target) => {\r\n    var targetLen = target.length\r\n    var beginningIndexes = []; var beginningIndexesLen = 0\r\n    var wasUpper = false\r\n    var wasAlphanum = false\r\n    for(var i = 0; i < targetLen; ++i) {\r\n      var targetCode = target.charCodeAt(i)\r\n      var isUpper = targetCode>=65&&targetCode<=90\r\n      var isAlphanum = isUpper || targetCode>=97&&targetCode<=122 || targetCode>=48&&targetCode<=57\r\n      var isBeginning = isUpper && !wasUpper || !wasAlphanum || !isAlphanum\r\n      wasUpper = isUpper\r\n      wasAlphanum = isAlphanum\r\n      if(isBeginning) beginningIndexes[beginningIndexesLen++] = i\r\n    }\r\n    return beginningIndexes\r\n  }\r\n  var prepareNextBeginningIndexes = (target) => {\r\n    target = remove_accents(target)\r\n    var targetLen = target.length\r\n    var beginningIndexes = prepareBeginningIndexes(target)\r\n    var nextBeginningIndexes = [] // new Array(targetLen)     sparse array is too slow\r\n    var lastIsBeginning = beginningIndexes[0]\r\n    var lastIsBeginningI = 0\r\n    for(var i = 0; i < targetLen; ++i) {\r\n      if(lastIsBeginning > i) {\r\n        nextBeginningIndexes[i] = lastIsBeginning\r\n      } else {\r\n        lastIsBeginning = beginningIndexes[++lastIsBeginningI]\r\n        nextBeginningIndexes[i] = lastIsBeginning===undefined ? targetLen : lastIsBeginning\r\n      }\r\n    }\r\n    return nextBeginningIndexes\r\n  }\r\n\r\n  var preparedCache       = new Map()\r\n  var preparedSearchCache = new Map()\r\n\r\n  // the theory behind these being globals is to reduce garbage collection by not making new arrays\r\n  var matchesSimple = []; var matchesStrict = []\r\n  var nextBeginningIndexesChanges = [] // allows straw berry to match strawberry well, by modifying the end of a substring to be considered a beginning index for the rest of the search\r\n  var keysSpacesBestScores = []; var allowPartialMatchScores = []\r\n  var tmpTargets = []; var tmpResults = []\r\n\r\n  // prop = 'key'                  2.5ms optimized for this case, seems to be about as fast as direct obj[prop]\r\n  // prop = 'key1.key2'            10ms\r\n  // prop = ['key1', 'key2']       27ms\r\n  // prop = obj => obj.tags.join() ??ms\r\n  var getValue = (obj, prop) => {\r\n    var tmp = obj[prop]; if(tmp !== undefined) return tmp\r\n    if(typeof prop === 'function') return prop(obj) // this should run first. but that makes string props slower\r\n    var segs = prop\r\n    if(!Array.isArray(prop)) segs = prop.split('.')\r\n    var len = segs.length\r\n    var i = -1\r\n    while (obj && (++i < len)) obj = obj[segs[i]]\r\n    return obj\r\n  }\r\n\r\n  var isPrepared = (x) => { return typeof x === 'object' && typeof x._bitflags === 'number' }\r\n  var INFINITY = Infinity; var NEGATIVE_INFINITY = -INFINITY\r\n  var noResults = []; noResults.total = 0\r\n  var NULL = null\r\n\r\n  var noTarget = prepare('')\r\n\r\n  // Hacked version of https://github.com/lemire/FastPriorityQueue.js\r\n  var fastpriorityqueue=r=>{var e=[],o=0,a={},v=r=>{for(var a=0,v=e[a],c=1;c<o;){var s=c+1;a=c,s<o&&e[s]._score<e[c]._score&&(a=s),e[a-1>>1]=e[a],c=1+(a<<1)}for(var f=a-1>>1;a>0&&v._score<e[f]._score;f=(a=f)-1>>1)e[a]=e[f];e[a]=v};return a.add=(r=>{var a=o;e[o++]=r;for(var v=a-1>>1;a>0&&r._score<e[v]._score;v=(a=v)-1>>1)e[a]=e[v];e[a]=r}),a.poll=(r=>{if(0!==o){var a=e[0];return e[0]=e[--o],v(),a}}),a.peek=(r=>{if(0!==o)return e[0]}),a.replaceTop=(r=>{e[0]=r,v()}),a}\r\n  var q = fastpriorityqueue() // reuse this\r\n\r\n  // fuzzysort is written this way for minification. all names are mangeled unless quoted\r\n  return {'single':single, 'go':go, 'prepare':prepare, 'cleanup':cleanup}\r\n}) // UMD\r\n"],
  "mappings": ";;;;;AAAA;AAAA;AAGC,KAAC,CAAC,MAAM,QAAQ;AACf,UAAG,OAAO,WAAW,cAAc,OAAO,IAAK,QAAO,CAAC,GAAG,GAAG;AAAA,eACrD,OAAO,WAAW,YAAY,OAAO,QAAS,QAAO,UAAU,IAAI;AAAA,UACtE,MAAK,WAAW,IAAI,IAAI;AAAA,IAC/B,GAAG,SAAM,OAAK;AACZ;AAEA,UAAI,SAAS,CAAC,QAAQ,WAAW;AAC/B,YAAG,CAAC,UAAU,CAAC,OAAQ,QAAO;AAE9B,YAAI,iBAAiB,kBAAkB,MAAM;AAC7C,YAAG,CAAC,WAAW,MAAM,EAAG,UAAS,YAAY,MAAM;AAEnD,YAAI,iBAAiB,eAAe;AACpC,aAAI,iBAAiB,OAAO,eAAe,eAAgB,QAAO;AAElE,eAAO,UAAU,gBAAgB,MAAM;AAAA,MACzC;AAEA,UAAI,KAAK,CAAC,QAAQ,SAAS,YAAY;AACrC,YAAG,CAAC,OAAQ,QAAO,SAAS,MAAM,IAAI,SAAS,OAAO,IAAI;AAE1D,YAAI,iBAAiB,kBAAkB,MAAM;AAC7C,YAAI,iBAAiB,eAAe;AACpC,YAAI,gBAAiB,eAAe;AAEpC,YAAI,YAAY,iBAAkB,SAAS,aAAa,CAAE;AAC1D,YAAI,QAAY,SAAS,SAAS;AAElC,YAAI,aAAa;AAAG,YAAI,eAAe;AACvC,YAAI,aAAa,QAAQ;AAEzB,iBAAS,YAAYA,SAAQ;AAC3B,cAAG,aAAa,OAAO;AAAE,cAAE,IAAIA,OAAM;AAAG,cAAE;AAAA,UAAW,OAChD;AACH,cAAE;AACF,gBAAGA,QAAO,SAAS,EAAE,KAAK,EAAE,OAAQ,GAAE,WAAWA,OAAM;AAAA,UACzD;AAAA,QACF;AAKA,YAAG,SAAS,KAAK;AACf,cAAI,MAAM,QAAQ;AAClB,mBAAQ,IAAI,GAAG,IAAI,YAAY,EAAE,GAAG;AAAE,gBAAI,MAAM,QAAQ,CAAC;AACvD,gBAAI,SAAS,SAAS,KAAK,GAAG;AAC9B,gBAAG,CAAC,OAAQ;AACZ,gBAAG,CAAC,WAAW,MAAM,EAAG,UAAS,YAAY,MAAM;AAEnD,iBAAI,iBAAiB,OAAO,eAAe,eAAgB;AAC3D,gBAAI,SAAS,UAAU,gBAAgB,MAAM;AAC7C,gBAAG,WAAW,KAAM;AACpB,gBAAG,OAAO,SAAS,UAAW;AAE9B,mBAAO,MAAM;AACb,wBAAY,MAAM;AAAA,UACpB;AAAA,QAGF,WAAU,SAAS,MAAM;AACvB,cAAI,OAAO,QAAQ;AACnB,cAAI,UAAU,KAAK;AAEnB,gBAAO,UAAQ,IAAI,GAAG,IAAI,YAAY,EAAE,GAAG;AAAE,gBAAI,MAAM,QAAQ,CAAC;AAE9D;AACE,kBAAI,eAAe;AACnB,uBAAS,OAAO,GAAG,OAAO,SAAS,EAAE,MAAM;AACzC,oBAAI,MAAM,KAAK,IAAI;AACnB,oBAAI,SAAS,SAAS,KAAK,GAAG;AAC9B,oBAAG,CAAC,QAAQ;AAAE,6BAAW,IAAI,IAAI;AAAU;AAAA,gBAAS;AACpD,oBAAG,CAAC,WAAW,MAAM,EAAG,UAAS,YAAY,MAAM;AACnD,2BAAW,IAAI,IAAI;AAEnB,gCAAgB,OAAO;AAAA,cACzB;AAEA,mBAAI,iBAAiB,kBAAkB,eAAgB;AAAA,YACzD;AAEA,gBAAG,cAAe,UAAQC,KAAE,GAAGA,KAAE,eAAe,cAAc,QAAQA,KAAK,sBAAqBA,EAAC,IAAI;AAErG,qBAAS,OAAO,GAAG,OAAO,SAAS,EAAE,MAAM;AACzC,uBAAS,WAAW,IAAI;AACxB,kBAAG,WAAW,UAAU;AAAE,2BAAW,IAAI,IAAI;AAAU;AAAA,cAAS;AAEhE,yBAAW,IAAI,IAAI;AAAA,gBAAU;AAAA,gBAAgB;AAAA;AAAA,gBAAwB;AAAA;AAAA,gBAA6B;AAAA,cAAa;AAC/G,kBAAG,WAAW,IAAI,MAAM,MAAM;AAAE,2BAAW,IAAI,IAAI;AAAU;AAAA,cAAS;AAItE,kBAAG,cAAe,UAAQA,KAAE,GAAGA,KAAE,eAAe,cAAc,QAAQA,MAAK;AACzE,oBAAG,wBAAwBA,EAAC,IAAI,MAAO;AACrC,sBAAG,qBAAqBA,EAAC,IAAI,mBAAmB;AAC9C,wBAAI,OAAO,qBAAqBA,EAAC,IAAI,wBAAwBA,EAAC,KAAK;AACnE,wBAAG,MAAM,qBAAqBA,EAAC,EAAG,sBAAqBA,EAAC,IAAI;AAAA,kBAC9D;AAAA,gBACF;AACA,oBAAG,wBAAwBA,EAAC,IAAI,qBAAqBA,EAAC,EAAG,sBAAqBA,EAAC,IAAI,wBAAwBA,EAAC;AAAA,cAC9G;AAAA,YACF;AAEA,gBAAG,eAAe;AAChB,uBAAQA,KAAE,GAAGA,KAAE,eAAe,cAAc,QAAQA,MAAK;AAAE,oBAAG,qBAAqBA,EAAC,MAAM,kBAAmB,UAAS;AAAA,cAAM;AAAA,YAC9H,OAAO;AACL,kBAAI,mBAAmB;AACvB,uBAAQA,KAAE,GAAGA,KAAI,SAASA,MAAK;AAAE,oBAAG,WAAWA,EAAC,EAAE,WAAW,mBAAmB;AAAE,qCAAmB;AAAM;AAAA,gBAAM;AAAA,cAAE;AACnH,kBAAG,CAAC,iBAAkB;AAAA,YACxB;AAEA,gBAAI,aAAa,IAAI,WAAW,OAAO;AACvC,qBAAQA,KAAE,GAAGA,KAAI,SAASA,MAAK;AAAE,yBAAWA,EAAC,IAAI,WAAWA,EAAC;AAAA,YAAE;AAE/D,gBAAG,eAAe;AAChB,kBAAI,QAAQ;AACZ,uBAAQA,KAAE,GAAGA,KAAE,eAAe,cAAc,QAAQA,KAAK,UAAS,qBAAqBA,EAAC;AAAA,YAC1F,OAAO;AAGL,kBAAI,QAAQ;AACZ,uBAAQA,KAAE,GAAGA,KAAE,SAASA,MAAK;AAC3B,oBAAI,SAAS,WAAWA,EAAC;AACzB,oBAAG,OAAO,SAAS,MAAO;AACxB,sBAAG,QAAQ,mBAAmB;AAC5B,wBAAI,OAAO,QAAQ,OAAO,UAAU;AACpC,wBAAG,MAAM,MAAO,SAAQ;AAAA,kBAC1B;AAAA,gBACF;AACA,oBAAG,OAAO,SAAS,MAAO,SAAQ,OAAO;AAAA,cAC3C;AAAA,YACF;AAEA,uBAAW,MAAM;AACjB,uBAAW,SAAS;AACpB,gBAAG,SAAS,SAAS;AACnB,sBAAQ,QAAQ,QAAQ,UAAU;AAClC,kBAAG,CAAC,MAAO;AACX,sBAAQ,iBAAiB,KAAK;AAC9B,yBAAW,SAAS;AAAA,YACtB;AAEA,gBAAG,QAAQ,UAAW;AACtB,wBAAY,UAAU;AAAA,UACxB;AAAA,QAGF,OAAO;AACL,mBAAQ,IAAI,GAAG,IAAI,YAAY,EAAE,GAAG;AAAE,gBAAI,SAAS,QAAQ,CAAC;AAC1D,gBAAG,CAAC,OAAQ;AACZ,gBAAG,CAAC,WAAW,MAAM,EAAG,UAAS,YAAY,MAAM;AAEnD,iBAAI,iBAAiB,OAAO,eAAe,eAAgB;AAC3D,gBAAI,SAAS,UAAU,gBAAgB,MAAM;AAC7C,gBAAG,WAAW,KAAM;AACpB,gBAAG,OAAO,SAAS,UAAW;AAE9B,wBAAY,MAAM;AAAA,UACpB;AAAA,QACF;AAEA,YAAG,eAAe,EAAG,QAAO;AAC5B,YAAI,UAAU,IAAI,MAAM,UAAU;AAClC,iBAAQ,IAAI,aAAa,GAAG,KAAK,GAAG,EAAE,EAAG,SAAQ,CAAC,IAAI,EAAE,KAAK;AAC7D,gBAAQ,QAAQ,aAAa;AAC7B,eAAO;AAAA,MACT;AAKA,UAAI,YAAY,CAAC,QAAQ,OAAK,OAAO,QAAM,WAAW;AACpD,YAAI,WAAW,OAAO,SAAS,aAAa,OAAO;AAEnD,YAAI,SAAc,OAAO;AACzB,YAAI,YAAc,OAAO;AACzB,YAAI,UAAc,OAAO;AACzB,YAAI,cAAc;AAClB,YAAI,SAAc;AAClB,YAAI,WAAc;AAClB,YAAI,SAAc;AAClB,YAAI,QAAc,CAAC;AAEnB,iBAAQ,IAAI,GAAG,IAAI,WAAW,EAAE,GAAG;AAAE,cAAI,OAAO,OAAO,CAAC;AACtD,cAAG,QAAQ,QAAQ,MAAM,GAAG;AAC1B,cAAE;AACF,gBAAG,CAAC,QAAQ;AAAE,uBAAS;AACrB,kBAAG,UAAU;AACX,sBAAM,KAAK,WAAW;AAAG,8BAAc;AAAA,cACzC,OAAO;AACL,+BAAe;AAAA,cACjB;AAAA,YACF;AAEA,gBAAG,aAAa,QAAQ,QAAQ;AAC9B,kBAAG,UAAU;AACX,+BAAe;AACf,sBAAM,KAAK,SAAS,aAAa,QAAQ,CAAC;AAAG,8BAAc;AAC3D,sBAAM,KAAK,OAAO,OAAO,IAAE,CAAC,CAAC;AAAA,cAC/B,OAAO;AACL,+BAAe,OAAO,QAAQ,OAAO,OAAO,IAAE,CAAC;AAAA,cACjD;AACA;AAAA,YACF;AAAA,UACF,OAAO;AACL,gBAAG,QAAQ;AAAE,uBAAS;AACpB,kBAAG,UAAU;AACX,sBAAM,KAAK,SAAS,aAAa,QAAQ,CAAC;AAAG,8BAAc;AAAA,cAC7D,OAAO;AACL,+BAAe;AAAA,cACjB;AAAA,YACF;AAAA,UACF;AACA,yBAAe;AAAA,QACjB;AAEA,eAAO,WAAW,QAAQ;AAAA,MAC5B;AAGA,UAAI,UAAU,CAAC,WAAW;AACxB,YAAG,OAAO,WAAW,SAAU,UAAS,KAAG;AAAA,iBACnC,OAAO,WAAW,SAAU,UAAS;AAC7C,YAAI,OAAO,iBAAiB,MAAM;AAClC,eAAO,WAAW,QAAQ,EAAC,cAAa,KAAK,QAAQ,mBAAkB,KAAK,YAAY,WAAU,KAAK,SAAQ,CAAC;AAAA,MAClH;AAEA,UAAI,UAAU,MAAM;AAAE,sBAAc,MAAM;AAAG,4BAAoB,MAAM;AAAA,MAAE;AAAA,MASzE,MAAM,OAAO;AAAA,QACX,KAAK,SAAS,IAAI;AAAE,iBAAO,KAAK,SAAS,MAAM,GAAG,KAAK,SAAS,GAAG,EAAE,KAAK,CAAC,GAAE,MAAI,IAAE,CAAC;AAAA,QAAE;AAAA,QACtF,KAAK,SAAS,EAAE,SAAS;AAAE,iBAAO,KAAK,WAAW;AAAA,QAAQ;AAAA,QAC1D,CAAC,WAAW,EAAE,MAAM,OAAO;AAAE,iBAAO,UAAU,MAAM,MAAM,KAAK;AAAA,QAAE;AAAA,QACjE,KAAK,OAAO,IAAI;AAAE,iBAAO,eAAe,KAAK,MAAM;AAAA,QAAE;AAAA,QACrD,KAAK,OAAO,EAAE,OAAO;AAAE,eAAK,SAAS,iBAAiB,KAAK;AAAA,QAAE;AAAA,MAC/D;AAAA,MAEA,MAAM,mBAAmB,MAAM;AAAA,QAC7B,KAAK,OAAO,IAAI;AAAE,iBAAO,eAAe,KAAK,MAAM;AAAA,QAAE;AAAA,QACrD,KAAK,OAAO,EAAE,OAAO;AAAE,eAAK,SAAS,iBAAiB,KAAK;AAAA,QAAE;AAAA,MAC/D;AAEA,UAAI,aAAa,CAAC,QAAQ,YAAY;AACpC,cAAM,SAAS,IAAI,OAAO;AAC1B,eAAO,QAAQ,IAAgB;AAC/B,eAAO,KAAK,IAAmB,QAAQ,OAAyB;AAChE,eAAO,SAAwB,QAAQ,UAAyB;AAChE,eAAO,WAAwB,QAAQ,YAAyB,CAAC;AACjE,eAAO,eAAwB,QAAQ,gBAAyB;AAChE,eAAO,oBAAwB,QAAQ,qBAAyB;AAChE,eAAO,wBAAwB,QAAQ,yBAAyB;AAChE,eAAO,YAAwB,QAAQ,aAAyB;AAChE,eAAO;AAAA,MACT;AAGA,UAAI,iBAAiB,WAAS;AAC5B,YAAG,UAAU,kBAAmB,QAAO;AACvC,YAAG,QAAQ,EAAG,QAAO;AACrB,eAAO,KAAK,QAAS,CAAC,QAAQ,MAAI,UAAS,KAAK;AAAA,MAClD;AACA,UAAI,mBAAmB,qBAAmB;AACxC,YAAG,oBAAoB,EAAG,QAAO;AACjC,YAAG,kBAAkB,EAAG,QAAO;AAC/B,eAAO,IAAI,KAAK,IAAK,KAAK,IAAI,eAAe,IAAI,KAAK,GAAI,IAAI,OAAO;AAAA,MACvE;AAGA,UAAI,gBAAgB,CAAC,WAAW;AAC9B,YAAG,OAAO,WAAW,SAAU,UAAS,KAAG;AAAA,iBACnC,OAAO,WAAW,SAAU,UAAS;AAC7C,iBAAS,OAAO,KAAK;AACrB,YAAI,OAAO,iBAAiB,MAAM;AAElC,YAAI,gBAAgB,CAAC;AACrB,YAAG,KAAK,eAAe;AACrB,cAAI,WAAW,OAAO,MAAM,KAAK;AACjC,qBAAW,CAAC,GAAG,IAAI,IAAI,QAAQ,CAAC;AAChC,mBAAQ,IAAE,GAAG,IAAE,SAAS,QAAQ,KAAK;AACnC,gBAAG,SAAS,CAAC,MAAM,GAAI;AACvB,gBAAI,QAAQ,iBAAiB,SAAS,CAAC,CAAC;AACxC,0BAAc,KAAK,EAAC,YAAW,MAAM,YAAY,QAAO,SAAS,CAAC,EAAE,YAAY,GAAG,eAAc,MAAK,CAAC;AAAA,UACzG;AAAA,QACF;AAEA,eAAO,EAAC,YAAY,KAAK,YAAY,QAAQ,KAAK,QAAQ,eAAe,KAAK,eAAe,UAAU,KAAK,UAAU,cAA4B;AAAA,MACpJ;AAIA,UAAI,cAAc,CAAC,WAAW;AAC5B,YAAG,OAAO,SAAS,IAAK,QAAO,QAAQ,MAAM;AAC7C,YAAI,iBAAiB,cAAc,IAAI,MAAM;AAC7C,YAAG,mBAAmB,OAAW,QAAO;AACxC,yBAAiB,QAAQ,MAAM;AAC/B,sBAAc,IAAI,QAAQ,cAAc;AACxC,eAAO;AAAA,MACT;AACA,UAAI,oBAAoB,CAAC,WAAW;AAClC,YAAG,OAAO,SAAS,IAAK,QAAO,cAAc,MAAM;AACnD,YAAI,iBAAiB,oBAAoB,IAAI,MAAM;AACnD,YAAG,mBAAmB,OAAW,QAAO;AACxC,yBAAiB,cAAc,MAAM;AACrC,4BAAoB,IAAI,QAAQ,cAAc;AAC9C,eAAO;AAAA,MACT;AAGA,UAAI,MAAM,CAAC,SAAS,YAAY;AAC9B,YAAI,UAAU,CAAC;AAAG,gBAAQ,QAAQ,QAAQ;AAE1C,YAAI,QAAQ,SAAS,SAAS;AAE9B,YAAG,SAAS,KAAK;AACf,mBAAQ,IAAE,GAAE,IAAE,QAAQ,QAAO,KAAK;AAAE,gBAAI,MAAM,QAAQ,CAAC;AACrD,gBAAI,SAAS,SAAS,KAAK,QAAQ,GAAG;AACtC,gBAAG,UAAU,KAAM;AACnB,gBAAG,CAAC,WAAW,MAAM,EAAG,UAAS,YAAY,MAAM;AACnD,gBAAI,SAAS,WAAW,OAAO,QAAQ,EAAC,QAAQ,OAAO,QAAQ,IAAQ,CAAC;AACxE,oBAAQ,KAAK,MAAM;AAAG,gBAAG,QAAQ,UAAU,MAAO,QAAO;AAAA,UAC3D;AAAA,QACF,WAAU,SAAS,MAAM;AACvB,mBAAQ,IAAE,GAAE,IAAE,QAAQ,QAAO,KAAK;AAAE,gBAAI,MAAM,QAAQ,CAAC;AACrD,gBAAI,aAAa,IAAI,WAAW,QAAQ,KAAK,MAAM;AACnD,qBAAS,OAAO,QAAQ,KAAK,SAAS,GAAG,QAAQ,GAAG,EAAE,MAAM;AAC1D,kBAAI,SAAS,SAAS,KAAK,QAAQ,KAAK,IAAI,CAAC;AAC7C,kBAAG,CAAC,QAAQ;AAAE,2BAAW,IAAI,IAAI;AAAU;AAAA,cAAS;AACpD,kBAAG,CAAC,WAAW,MAAM,EAAG,UAAS,YAAY,MAAM;AACnD,qBAAO,SAAS;AAChB,qBAAO,SAAS,MAAM;AACtB,yBAAW,IAAI,IAAI;AAAA,YACrB;AACA,uBAAW,MAAM;AACjB,uBAAW,SAAS;AACpB,oBAAQ,KAAK,UAAU;AAAG,gBAAG,QAAQ,UAAU,MAAO,QAAO;AAAA,UAC/D;AAAA,QACF,OAAO;AACL,mBAAQ,IAAE,GAAE,IAAE,QAAQ,QAAO,KAAK;AAAE,gBAAI,SAAS,QAAQ,CAAC;AACxD,gBAAG,UAAU,KAAM;AACnB,gBAAG,CAAC,WAAW,MAAM,EAAG,UAAS,YAAY,MAAM;AACnD,mBAAO,SAAS;AAChB,mBAAO,SAAS,MAAM;AACtB,oBAAQ,KAAK,MAAM;AAAG,gBAAG,QAAQ,UAAU,MAAO,QAAO;AAAA,UAC3D;AAAA,QACF;AAEA,eAAO;AAAA,MACT;AAGA,UAAI,YAAY,CAAC,gBAAgB,UAAU,cAAY,OAAO,oBAAkB,UAAU;AACxF,YAAG,gBAAc,SAAS,eAAe,cAAe,QAAO,gBAAgB,gBAAgB,UAAU,iBAAiB;AAE1H,YAAI,cAAmB,eAAe;AACtC,YAAI,mBAAmB,eAAe;AACtC,YAAI,kBAAmB,iBAAiB,CAAC;AACzC,YAAI,mBAAmB,SAAS;AAChC,YAAI,YAAmB,iBAAiB;AACxC,YAAI,YAAmB,iBAAiB;AACxC,YAAI,UAAmB;AACvB,YAAI,UAAmB;AACvB,YAAI,mBAAmB;AAKvB,mBAAQ;AACN,cAAI,UAAU,oBAAoB,iBAAiB,OAAO;AAC1D,cAAG,SAAS;AACV,0BAAc,kBAAkB,IAAI;AACpC,cAAE;AAAS,gBAAG,YAAY,UAAW;AACrC,8BAAkB,iBAAiB,OAAO;AAAA,UAC5C;AACA,YAAE;AAAS,cAAG,WAAW,UAAW,QAAO;AAAA,QAC7C;AAEA,YAAI,UAAU;AACd,YAAI,gBAAgB;AACpB,YAAI,mBAAmB;AAEvB,YAAI,uBAAuB,SAAS;AACpC,YAAG,yBAAyB,KAAM,wBAAuB,SAAS,wBAAwB,4BAA4B,SAAS,MAAM;AACrI,kBAAU,cAAc,CAAC,MAAI,IAAI,IAAI,qBAAqB,cAAc,CAAC,IAAE,CAAC;AAK5E,YAAI,iBAAiB;AACrB,YAAG,YAAY,UAAW,YAAQ;AAChC,cAAG,WAAW,WAAW;AAEvB,gBAAG,WAAW,EAAG;AAEjB,cAAE;AAAgB,gBAAG,iBAAiB,IAAK;AAE3C,cAAE;AACF,gBAAI,YAAY,cAAc,EAAE,gBAAgB;AAChD,sBAAU,qBAAqB,SAAS;AAAA,UAE1C,OAAO;AACL,gBAAI,UAAU,iBAAiB,OAAO,MAAM,iBAAiB,OAAO;AACpE,gBAAG,SAAS;AACV,4BAAc,kBAAkB,IAAI;AACpC,gBAAE;AAAS,kBAAG,YAAY,WAAW;AAAE,gCAAgB;AAAM;AAAA,cAAM;AACnE,gBAAE;AAAA,YACJ,OAAO;AACL,wBAAU,qBAAqB,OAAO;AAAA,YACxC;AAAA,UACF;AAAA,QACF;AAGA,YAAI,iBAAiB,aAAa,IAAI,KAAK,SAAS,aAAa,QAAQ,aAAa,cAAc,CAAC,CAAC;AACtG,YAAI,cAAc,CAAC,CAAC,CAAC;AACrB,YAAI,uBAAuB,CAAC,cAAc,QAAQ,mBAAiB,KAAK,SAAS,sBAAsB,iBAAe,CAAC,MAAM;AAG7H,YAAG,eAAe,CAAC,sBAAsB;AACvC,mBAAQ,IAAE,GAAG,IAAE,qBAAqB,QAAQ,IAAE,qBAAqB,CAAC,GAAG;AACrE,gBAAG,KAAK,eAAgB;AAExB,qBAAQ,IAAE,GAAG,IAAE,WAAW,IAAK,KAAG,iBAAiB,CAAC,MAAM,SAAS,kBAAkB,IAAE,CAAC,EAAG;AAC3F,gBAAG,MAAM,WAAW;AAAE,+BAAiB;AAAG,qCAAuB;AAAM;AAAA,YAAM;AAAA,UAC/E;AAAA,QACF;AAMA,YAAI,iBAAiB,aAAW;AAC9B,cAAIC,SAAQ;AAEZ,cAAI,uBAAuB;AAC3B,mBAAQD,KAAI,GAAGA,KAAI,WAAW,EAAEA,IAAG;AACjC,gBAAG,QAAQA,EAAC,IAAI,QAAQA,KAAE,CAAC,MAAM,GAAG;AAAC,cAAAC,UAAS,QAAQD,EAAC;AAAG,gBAAE;AAAA,YAAoB;AAAA,UAClF;AACA,cAAI,oBAAoB,QAAQ,YAAU,CAAC,IAAI,QAAQ,CAAC,KAAK,YAAU;AAEvE,UAAAC,WAAU,KAAG,qBAAqB;AAElC,cAAG,QAAQ,CAAC,MAAM,EAAG,CAAAA,UAAS,QAAQ,CAAC,IAAE,QAAQ,CAAC,IAAE;AAEpD,cAAG,CAAC,eAAe;AACjB,YAAAA,UAAS;AAAA,UACX,OAAO;AAEL,gBAAI,yBAAyB;AAC7B,qBAAQD,KAAI,qBAAqB,CAAC,GAAGA,KAAI,WAAWA,KAAE,qBAAqBA,EAAC,EAAG,GAAE;AAEjF,gBAAG,yBAAyB,GAAI,CAAAC,WAAU,yBAAuB,MAAI;AAAA,UACvE;AAEA,UAAAA,WAAU,YAAY,aAAW;AAEjC,cAAG,YAAsB,CAAAA,UAAS,IAAE,YAAU,YAAU;AACxD,cAAG,qBAAsB,CAAAA,UAAS,IAAE,YAAU,YAAU;AAExD,UAAAA,WAAU,YAAY,aAAW;AAEjC,iBAAOA;AAAA,QACT;AAEA,YAAG,CAAC,eAAe;AACjB,cAAG,YAAa,UAAQ,IAAE,GAAG,IAAE,WAAW,EAAE,EAAG,eAAc,CAAC,IAAI,iBAAe;AACjF,cAAI,cAAc;AAClB,cAAI,QAAQ,eAAe,WAAW;AAAA,QACxC,OAAO;AACL,cAAG,sBAAsB;AACvB,qBAAQ,IAAE,GAAG,IAAE,WAAW,EAAE,EAAG,eAAc,CAAC,IAAI,iBAAe;AACjE,gBAAI,cAAc;AAClB,gBAAI,QAAQ,eAAe,aAAa;AAAA,UAC1C,OAAO;AACL,gBAAI,cAAc;AAClB,gBAAI,QAAQ,eAAe,aAAa;AAAA,UAC1C;AAAA,QACF;AAEA,iBAAS,SAAS;AAElB,iBAAQ,IAAI,GAAG,IAAI,WAAW,EAAE,EAAG,UAAS,SAAS,CAAC,IAAI,YAAY,CAAC;AACvE,iBAAS,SAAS,MAAM;AAExB,cAAM,SAAY,IAAI,OAAO;AAC7B,eAAO,SAAW,SAAS;AAC3B,eAAO,SAAW,SAAS;AAC3B,eAAO,WAAW,SAAS;AAC3B,eAAO;AAAA,MACT;AACA,UAAI,kBAAkB,CAAC,gBAAgB,QAAQ,sBAAsB;AACnE,YAAI,eAAe,oBAAI,IAAI;AAC3B,YAAI,QAAQ;AACZ,YAAI,SAAS;AAEb,YAAI,+BAA+B;AACnC,YAAI,WAAW,eAAe;AAC9B,YAAI,cAAc,SAAS;AAC3B,YAAI,aAAa;AAGjB,YAAI,4BAA4B,MAAM;AACpC,mBAAQD,KAAE,aAAW,GAAGA,MAAG,GAAGA,KAAK,QAAO,sBAAsB,4BAA4BA,KAAE,IAAI,CAAC,CAAC,IAAI,4BAA4BA,KAAE,IAAI,CAAC;AAAA,QAC7I;AAEA,YAAI,mBAAmB;AACvB,iBAAQ,IAAE,GAAG,IAAE,aAAa,EAAE,GAAG;AAC/B,kCAAwB,CAAC,IAAI;AAC7B,cAAI,SAAS,SAAS,CAAC;AAEvB,mBAAS,UAAU,QAAQ,MAAM;AACjC,cAAG,mBAAmB;AACpB,gBAAG,WAAW,KAAM;AACpB,+BAAmB;AAAA,UACrB,OAAO;AACL,gBAAG,WAAW,MAAM;AAAC,wCAA0B;AAAG,qBAAO;AAAA,YAAI;AAAA,UAC/D;AAGA,cAAI,kBAAkB,MAAM,cAAc;AAC1C,cAAG,CAAC,iBAAiB;AACnB,gBAAI,UAAU,OAAO;AAErB,gBAAI,gCAAgC;AACpC,qBAAQA,KAAE,GAAGA,KAAE,QAAQ,MAAI,GAAGA,MAAK;AACjC,kBAAG,QAAQA,KAAE,CAAC,IAAI,QAAQA,EAAC,MAAM,GAAG;AAClC,gDAAgC;AAAO;AAAA,cACzC;AAAA,YACF;AAEA,gBAAG,+BAA+B;AAChC,kBAAI,oBAAoB,QAAQ,QAAQ,MAAI,CAAC,IAAI;AACjD,kBAAI,YAAY,OAAO,sBAAsB,oBAAkB,CAAC;AAChE,uBAAQA,KAAE,oBAAkB,GAAGA,MAAG,GAAGA,MAAK;AACxC,oBAAG,cAAc,OAAO,sBAAsBA,EAAC,EAAG;AAClD,uBAAO,sBAAsBA,EAAC,IAAI;AAClC,4CAA4B,aAAW,IAAI,CAAC,IAAIA;AAChD,4CAA4B,aAAW,IAAI,CAAC,IAAI;AAChD;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAEA,mBAAS,OAAO,SAAS;AACzB,kCAAwB,CAAC,IAAI,OAAO,SAAS;AAG7C,cAAG,OAAO,SAAS,CAAC,IAAI,8BAA8B;AACpD,sBAAU,+BAA+B,OAAO,SAAS,CAAC,KAAK;AAAA,UACjE;AACA,yCAA+B,OAAO,SAAS,CAAC;AAEhD,mBAAQ,IAAE,GAAG,IAAE,OAAO,SAAS,KAAK,EAAE,EAAG,cAAa,IAAI,OAAO,SAAS,CAAC,CAAC;AAAA,QAC9E;AAEA,YAAG,qBAAqB,CAAC,iBAAkB,QAAO;AAElD,kCAA0B;AAG1B,YAAI,oBAAoB;AAAA,UAAU;AAAA,UAAgB;AAAA;AAAA,UAAwB;AAAA,QAAI;AAC9E,YAAG,sBAAsB,QAAQ,kBAAkB,SAAS,OAAO;AACjE,cAAG,mBAAmB;AACpB,qBAAQ,IAAE,GAAG,IAAE,aAAa,EAAE,GAAG;AAC/B,sCAAwB,CAAC,IAAI,kBAAkB,SAAS;AAAA,YAC1D;AAAA,UACF;AACA,iBAAO;AAAA,QACT;AAEA,YAAG,kBAAmB,UAAS;AAC/B,eAAO,SAAS;AAEhB,YAAI,IAAI;AACR,iBAAS,SAAS,aAAc,QAAO,SAAS,GAAG,IAAI;AACvD,eAAO,SAAS,MAAM;AAEtB,eAAO;AAAA,MACT;AAGA,UAAI,iBAAiB,CAAC,QAAQ,IAAI,QAAQ,WAAC,sBAAkB,IAAE,GAAE,WAAS,MAAM,UAAU,KAAK,CAAC,EAAE,QAAQ,oBAAoB,EAAE;AAEhI,UAAI,mBAAmB,CAAC,QAAQ;AAC9B,cAAM,eAAe,GAAG;AACxB,YAAI,SAAS,IAAI;AACjB,YAAI,QAAQ,IAAI,YAAY;AAC5B,YAAI,aAAa,CAAC;AAClB,YAAI,WAAW;AACf,YAAI,gBAAgB;AAEpB,iBAAQ,IAAI,GAAG,IAAI,QAAQ,EAAE,GAAG;AAC9B,cAAI,YAAY,WAAW,CAAC,IAAI,MAAM,WAAW,CAAC;AAElD,cAAG,cAAc,IAAI;AACnB,4BAAgB;AAChB;AAAA,UACF;AAEA,cAAI,MAAM,aAAW,MAAI,aAAW,MAAM,YAAU,KAC1C,aAAW,MAAI,aAAW,KAAM,KAEhC,aAAW,MAAqB,KACA;AAC1C,sBAAY,KAAG;AAAA,QACjB;AAEA,eAAO,EAAC,YAAuB,UAAmB,eAA6B,QAAO,MAAK;AAAA,MAC7F;AACA,UAAI,0BAA0B,CAAC,WAAW;AACxC,YAAI,YAAY,OAAO;AACvB,YAAI,mBAAmB,CAAC;AAAG,YAAI,sBAAsB;AACrD,YAAI,WAAW;AACf,YAAI,cAAc;AAClB,iBAAQ,IAAI,GAAG,IAAI,WAAW,EAAE,GAAG;AACjC,cAAI,aAAa,OAAO,WAAW,CAAC;AACpC,cAAI,UAAU,cAAY,MAAI,cAAY;AAC1C,cAAI,aAAa,WAAW,cAAY,MAAI,cAAY,OAAO,cAAY,MAAI,cAAY;AAC3F,cAAI,cAAc,WAAW,CAAC,YAAY,CAAC,eAAe,CAAC;AAC3D,qBAAW;AACX,wBAAc;AACd,cAAG,YAAa,kBAAiB,qBAAqB,IAAI;AAAA,QAC5D;AACA,eAAO;AAAA,MACT;AACA,UAAI,8BAA8B,CAAC,WAAW;AAC5C,iBAAS,eAAe,MAAM;AAC9B,YAAI,YAAY,OAAO;AACvB,YAAI,mBAAmB,wBAAwB,MAAM;AACrD,YAAI,uBAAuB,CAAC;AAC5B,YAAI,kBAAkB,iBAAiB,CAAC;AACxC,YAAI,mBAAmB;AACvB,iBAAQ,IAAI,GAAG,IAAI,WAAW,EAAE,GAAG;AACjC,cAAG,kBAAkB,GAAG;AACtB,iCAAqB,CAAC,IAAI;AAAA,UAC5B,OAAO;AACL,8BAAkB,iBAAiB,EAAE,gBAAgB;AACrD,iCAAqB,CAAC,IAAI,oBAAkB,SAAY,YAAY;AAAA,UACtE;AAAA,QACF;AACA,eAAO;AAAA,MACT;AAEA,UAAI,gBAAsB,oBAAI,IAAI;AAClC,UAAI,sBAAsB,oBAAI,IAAI;AAGlC,UAAI,gBAAgB,CAAC;AAAG,UAAI,gBAAgB,CAAC;AAC7C,UAAI,8BAA8B,CAAC;AACnC,UAAI,uBAAuB,CAAC;AAAG,UAAI,0BAA0B,CAAC;AAC9D,UAAI,aAAa,CAAC;AAAG,UAAI,aAAa,CAAC;AAMvC,UAAI,WAAW,CAAC,KAAK,SAAS;AAC5B,YAAI,MAAM,IAAI,IAAI;AAAG,YAAG,QAAQ,OAAW,QAAO;AAClD,YAAG,OAAO,SAAS,WAAY,QAAO,KAAK,GAAG;AAC9C,YAAI,OAAO;AACX,YAAG,CAAC,MAAM,QAAQ,IAAI,EAAG,QAAO,KAAK,MAAM,GAAG;AAC9C,YAAI,MAAM,KAAK;AACf,YAAI,IAAI;AACR,eAAO,OAAQ,EAAE,IAAI,IAAM,OAAM,IAAI,KAAK,CAAC,CAAC;AAC5C,eAAO;AAAA,MACT;AAEA,UAAI,aAAa,CAAC,MAAM;AAAE,eAAO,OAAO,MAAM,YAAY,OAAO,EAAE,cAAc;AAAA,MAAS;AAC1F,UAAI,WAAW;AAAU,UAAI,oBAAoB,CAAC;AAClD,UAAI,YAAY,CAAC;AAAG,gBAAU,QAAQ;AACtC,UAAI,OAAO;AAEX,UAAI,WAAW,QAAQ,EAAE;AAGzB,UAAI,oBAAkB,OAAG;AAAC,YAAI,IAAE,CAAC,GAAE,IAAE,GAAE,IAAE,CAAC,GAAE,IAAE,CAAAE,OAAG;AAAC,mBAAQC,KAAE,GAAEC,KAAE,EAAED,EAAC,GAAE,IAAE,GAAE,IAAE,KAAG;AAAC,gBAAI,IAAE,IAAE;AAAE,YAAAA,KAAE,GAAE,IAAE,KAAG,EAAE,CAAC,EAAE,SAAO,EAAE,CAAC,EAAE,WAASA,KAAE,IAAG,EAAEA,KAAE,KAAG,CAAC,IAAE,EAAEA,EAAC,GAAE,IAAE,KAAGA,MAAG;AAAA,UAAE;AAAC,mBAAQ,IAAEA,KAAE,KAAG,GAAEA,KAAE,KAAGC,GAAE,SAAO,EAAE,CAAC,EAAE,QAAO,KAAGD,KAAE,KAAG,KAAG,EAAE,GAAEA,EAAC,IAAE,EAAE,CAAC;AAAE,YAAEA,EAAC,IAAEC;AAAA,QAAC;AAAE,eAAO,EAAE,MAAK,CAAAF,OAAG;AAAC,cAAIC,KAAE;AAAE,YAAE,GAAG,IAAED;AAAE,mBAAQE,KAAED,KAAE,KAAG,GAAEA,KAAE,KAAGD,GAAE,SAAO,EAAEE,EAAC,EAAE,QAAOA,MAAGD,KAAEC,MAAG,KAAG,EAAE,GAAED,EAAC,IAAE,EAAEC,EAAC;AAAE,YAAED,EAAC,IAAED;AAAA,QAAC,GAAG,EAAE,OAAM,CAAAA,OAAG;AAAC,cAAG,MAAI,GAAE;AAAC,gBAAIC,KAAE,EAAE,CAAC;AAAE,mBAAO,EAAE,CAAC,IAAE,EAAE,EAAE,CAAC,GAAE,EAAE,GAAEA;AAAA,UAAC;AAAA,QAAC,GAAG,EAAE,OAAM,CAAAD,OAAG;AAAC,cAAG,MAAI,EAAE,QAAO,EAAE,CAAC;AAAA,QAAC,GAAG,EAAE,aAAY,CAAAA,OAAG;AAAC,YAAE,CAAC,IAAEA,IAAE,EAAE;AAAA,QAAC,GAAG;AAAA,MAAC;AACnd,UAAI,IAAI,kBAAkB;AAG1B,aAAO,EAAC,UAAS,QAAQ,MAAK,IAAI,WAAU,SAAS,WAAU,QAAO;AAAA,IACxE,CAAC;AAAA;AAAA;",
  "names": ["result", "i", "score", "r", "a", "v"]
}
